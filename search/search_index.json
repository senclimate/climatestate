{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to ClimateState! Documentation: https://senclimate.github.io/climatestate/ ClimateState is a library designed for visualizing the state of climate in atmosphere and ocean. It goes beyond merely presenting figures; it also showcases the underlying code that generates these visual representations. This is particularly beneficial for students and researchers, as it offers a transparent view into the process of climate data visualization, thereby fostering an environment of transparency and educational growth in the realm of climate science. Features \u00b6 To be added Methods \u00b6 We use monthly gridded observation/reanalysis datasets listed as follows Sea surface temperature NOAA Extended Reconstructed Sea Surface Temperature (ERSST) V5 obtained from https://psl.noaa.gov/data/gridded/data.noaa.ersst.v5.html HadISST obtained from https://www.metoffice.gov.uk/hadobs/hadisst/ COBE SST obtained from https://psl.noaa.gov/data/gridded/data.cobe.html Precipitation CPC Merged Analysis of Precipitation (CMAP) obtained from https://psl.noaa.gov/data/gridded/data.cmap.html ERA5 reanalysis ORAS5 ocean reanalysis All the climatology is calculated using the period of 1991-2020, unless specifically stated otherwise. Creator \u00b6 Dr. Sen Zhao is the project creator and primary contributor. He is an Assistant Researcher at University of Hawaii at Manoa\u2019s Department of Atmospheric Science. More details refer to his work . Acknowledgments \u00b6 To be added","title":"Home"},{"location":"#features","text":"To be added","title":"Features"},{"location":"#methods","text":"We use monthly gridded observation/reanalysis datasets listed as follows Sea surface temperature NOAA Extended Reconstructed Sea Surface Temperature (ERSST) V5 obtained from https://psl.noaa.gov/data/gridded/data.noaa.ersst.v5.html HadISST obtained from https://www.metoffice.gov.uk/hadobs/hadisst/ COBE SST obtained from https://psl.noaa.gov/data/gridded/data.cobe.html Precipitation CPC Merged Analysis of Precipitation (CMAP) obtained from https://psl.noaa.gov/data/gridded/data.cmap.html ERA5 reanalysis ORAS5 ocean reanalysis All the climatology is calculated using the period of 1991-2020, unless specifically stated otherwise.","title":"Methods"},{"location":"#creator","text":"Dr. Sen Zhao is the project creator and primary contributor. He is an Assistant Researcher at University of Hawaii at Manoa\u2019s Department of Atmospheric Science. More details refer to his work .","title":"Creator"},{"location":"#acknowledgments","text":"To be added","title":"Acknowledgments"},{"location":"Clim_sst_map/","text":"SST map \u00b6 % config IPCompleter . greedy = True % matplotlib inline % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 # ignore warnings import warnings warnings . filterwarnings ( 'ignore' ) import numpy as np import xarray as xr import matplotlib import matplotlib.colors as colors import senpy as sp from senpy import cmap ## time_slice = slice ( '1979-01' , '2022-12' ) prec_ds = xr . open_dataset ( '/export/epekema/zhaos/data/sst/ERSSTv5/sst.mon.mean_1x1.nc' ) . sel ( time = time_slice )[ 'sst' ] prec_ds = prec_ds . reindex ( lat = sorted ( prec_ds . lat )) prec_ds = sp . add_cyclic_point ( prec_ds , dim = 'lon' ) prec_m = prec_ds . groupby ( 'time.month' ) . mean () prec_a = prec_ds . groupby ( 'time.month' ) - prec_m prec_stddev = prec_a . std ( 'time' ) group_var = { 'All-Months' : prec_m . mean ( 'month' ), 'DJF' : prec_m . sel ( month = [ 12 , 1 , 12 ]) . mean ( 'month' ), 'MAM' : prec_m . sel ( month = [ 3 , 4 , 5 ]) . mean ( 'month' ), 'JJA' : prec_m . sel ( month = [ 6 , 7 , 8 ]) . mean ( 'month' ), 'SON' : prec_m . sel ( month = [ 9 , 10 , 11 ]) . mean ( 'month' ), } # fig = cmap.listview_cmaps() prC_clevs , prC_cmap , prC_norm = cmap . level_cmap_norms ( name = 'BlGrYeOrReVi200' , reverse = False , levels = np . arange ( 0 , 30 , step = 1 ), extend = 'both' ,) prC_cmap # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, ax = sp.map_subplots( 1, 1, figsize=(6, 3), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , ax = sp . map_subplots ( 1 , 1 , figsize = ( 6 , 4 ), proj = 'cyl' , lon_0 = 205 , aspect = 1.25 , layout = 'compressed' ) sea = 'All-Months' var_ds = group_var [ sea ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs [:: 4 ]) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) ax . set_title ( 'Precipiation annual mean climatology: 1979-2022' , fontsize = 'x-large' , fontweight = 'bold' ) sp . savefig ( fig , 'Clim_sst_ann.pdf' ) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 4, 1, figsize=(6, 11), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , axes = sp . map_subplots ( 4 , 1 , figsize = ( 6 , 12 ), proj = 'cyl' , lon_0 = 180 , aspect = 1.25 , layout = 'compressed' ) for i , sea in enumerate ([ 'DJF' , 'MAM' , 'JJA' , 'SON' ]): ax = axes . flat [ i ] var_ds = group_var [ sea ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) ax . set_title ( sea , fontsize = 'x-large' , fontweight = 'bold' ) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs [:: 4 ]) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) sp . set_legend_alphabet ( fig , axes . flat , x = 0.05 , y = 0.98 ) sp . savefig ( fig , 'Clim_sst_seasons.pdf' ) from scipy.ndimage import gaussian_filter def smooth_gaussian ( scalar_grid , n ): # Compute standard deviation in a manner consistent with GEMPAK n = int ( round ( n )) n = max ( n , 2 ) sgma = n / ( 2 * np . pi ) # Construct sigma sequence so smoothing occurs only in horizontal direction num_ax = len ( scalar_grid . shape ) # Assume the last two axes represent the horizontal directions sgma_seq = [ sgma if i > num_ax - 3 else 0 for i in range ( num_ax )] filter_args = { 'sigma' : sgma_seq , 'truncate' : 2 * np . sqrt ( 2 )} if hasattr ( scalar_grid , 'mask' ): smoothed = gaussian_filter ( scalar_grid . data , ** filter_args ) return np . ma . array ( smoothed , mask = scalar_grid . mask ) else : return gaussian_filter ( scalar_grid , ** filter_args ) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, ax = sp.map_subplots( 1, 1, figsize=(6, 3), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , axes = sp . map_subplots ( 2 , 1 , figsize = ( 6 , 8 ), proj = 'cyl' , lon_0 = 205 , aspect = 1.25 , layout = 'compressed' ) ds_lists = list ( [ group_var [ 'MAM' ], xr . apply_ufunc ( smooth_gaussian , group_var [ 'MAM' ], kwargs = { 'n' : 4 }) ]) for i , ax in enumerate ( axes . flat ): var_ds = ds_lists [ i ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs ) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) # ax.set_title('Precipiation annual mean climatology: 1979-2022', fontsize='x-large', fontweight='bold')","title":"Sea surface temperature"},{"location":"Clim_sst_map/#sst-map","text":"% config IPCompleter . greedy = True % matplotlib inline % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 # ignore warnings import warnings warnings . filterwarnings ( 'ignore' ) import numpy as np import xarray as xr import matplotlib import matplotlib.colors as colors import senpy as sp from senpy import cmap ## time_slice = slice ( '1979-01' , '2022-12' ) prec_ds = xr . open_dataset ( '/export/epekema/zhaos/data/sst/ERSSTv5/sst.mon.mean_1x1.nc' ) . sel ( time = time_slice )[ 'sst' ] prec_ds = prec_ds . reindex ( lat = sorted ( prec_ds . lat )) prec_ds = sp . add_cyclic_point ( prec_ds , dim = 'lon' ) prec_m = prec_ds . groupby ( 'time.month' ) . mean () prec_a = prec_ds . groupby ( 'time.month' ) - prec_m prec_stddev = prec_a . std ( 'time' ) group_var = { 'All-Months' : prec_m . mean ( 'month' ), 'DJF' : prec_m . sel ( month = [ 12 , 1 , 12 ]) . mean ( 'month' ), 'MAM' : prec_m . sel ( month = [ 3 , 4 , 5 ]) . mean ( 'month' ), 'JJA' : prec_m . sel ( month = [ 6 , 7 , 8 ]) . mean ( 'month' ), 'SON' : prec_m . sel ( month = [ 9 , 10 , 11 ]) . mean ( 'month' ), } # fig = cmap.listview_cmaps() prC_clevs , prC_cmap , prC_norm = cmap . level_cmap_norms ( name = 'BlGrYeOrReVi200' , reverse = False , levels = np . arange ( 0 , 30 , step = 1 ), extend = 'both' ,) prC_cmap # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, ax = sp.map_subplots( 1, 1, figsize=(6, 3), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , ax = sp . map_subplots ( 1 , 1 , figsize = ( 6 , 4 ), proj = 'cyl' , lon_0 = 205 , aspect = 1.25 , layout = 'compressed' ) sea = 'All-Months' var_ds = group_var [ sea ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs [:: 4 ]) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) ax . set_title ( 'Precipiation annual mean climatology: 1979-2022' , fontsize = 'x-large' , fontweight = 'bold' ) sp . savefig ( fig , 'Clim_sst_ann.pdf' ) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 4, 1, figsize=(6, 11), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , axes = sp . map_subplots ( 4 , 1 , figsize = ( 6 , 12 ), proj = 'cyl' , lon_0 = 180 , aspect = 1.25 , layout = 'compressed' ) for i , sea in enumerate ([ 'DJF' , 'MAM' , 'JJA' , 'SON' ]): ax = axes . flat [ i ] var_ds = group_var [ sea ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) ax . set_title ( sea , fontsize = 'x-large' , fontweight = 'bold' ) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs [:: 4 ]) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) sp . set_legend_alphabet ( fig , axes . flat , x = 0.05 , y = 0.98 ) sp . savefig ( fig , 'Clim_sst_seasons.pdf' ) from scipy.ndimage import gaussian_filter def smooth_gaussian ( scalar_grid , n ): # Compute standard deviation in a manner consistent with GEMPAK n = int ( round ( n )) n = max ( n , 2 ) sgma = n / ( 2 * np . pi ) # Construct sigma sequence so smoothing occurs only in horizontal direction num_ax = len ( scalar_grid . shape ) # Assume the last two axes represent the horizontal directions sgma_seq = [ sgma if i > num_ax - 3 else 0 for i in range ( num_ax )] filter_args = { 'sigma' : sgma_seq , 'truncate' : 2 * np . sqrt ( 2 )} if hasattr ( scalar_grid , 'mask' ): smoothed = gaussian_filter ( scalar_grid . data , ** filter_args ) return np . ma . array ( smoothed , mask = scalar_grid . mask ) else : return gaussian_filter ( scalar_grid , ** filter_args ) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, ax = sp.map_subplots( 1, 1, figsize=(6, 3), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , axes = sp . map_subplots ( 2 , 1 , figsize = ( 6 , 8 ), proj = 'cyl' , lon_0 = 205 , aspect = 1.25 , layout = 'compressed' ) ds_lists = list ( [ group_var [ 'MAM' ], xr . apply_ufunc ( smooth_gaussian , group_var [ 'MAM' ], kwargs = { 'n' : 4 }) ]) for i , ax in enumerate ( axes . flat ): var_ds = ds_lists [ i ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs ) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) # ax.set_title('Precipiation annual mean climatology: 1979-2022', fontsize='x-large', fontweight='bold')","title":"SST map"},{"location":"Clim_winds_map/","text":"\ud83c\udf0d Wind-driven ocean criculation \ud83c\udf0a \u00b6 Codes \u00b6 Load basic library for calculating and visualization % config IPCompleter . greedy = True % matplotlib inline % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 import warnings warnings . filterwarnings ( 'ignore' ) import numpy as np import xarray as xr import senpy as sp Load ERA5 reanalysis surface winds wind_ds = sp . ERA5_onelevel_vars ( vars = [ 'u10' , 'v10' ], time_slice = slice ( '1979-01' , '2022-12' )) wind_m = wind_ds . clim . climatology ( clim_slice = slice ( '1979-01' , '2022-12' )) . mean ( 'month' ) . load () plot annual mean surface wind climatology and overlayed image of ocean currents pattern credited from NASA images (ftp://public.sos.noaa.gov/oceans/) dlon = 10 dlat = 5 u = wind_m [ 'u10' ][:: dlat , :: dlon ] v = wind_m [ 'v10' ][:: dlat , :: dlon ] fig , ax = sp . map_subplots ( 1 , 1 , figsize = ( 10 , 5 ), proj = 'robin' , lon_0 = 200 , aspect = 1.2 , layout = 'compressed' ) quiver_scale = 40 # 40 m/s corresponds to 1 inch on the plot quiver_key_length = 10 # The reference arrow in the legend represents 10 m/s Q = ax . quiver ( u . lon , u . lat , u . values , v . values , scale = quiver_scale , scale_units = 'inches' , transform = sp . data_crs , pivot = 'middle' , color = 'blue' , zorder = 5 , alpha = 0.7 ) # Add a key to the plot to show vector scale qk = ax . quiverkey ( Q , 0.95 , 0.93 , quiver_key_length , f \" { quiver_key_length } m/s\" , labelpos = 'N' , coordinates = 'axes' ) # sp.map_coastline(ax, color='green') sp . map_landmask ( ax , fc = 'white' , alpha = 0.1 ) sp . map_ticks ( ax , lon_ticks = np . arange ( 20 , 360 , step = 60 ) ) ax . set_title ( \"Climatological surface winds and ocean currents\" , fontsize = 14 , fontweight = 'bold' ) sp . map_background_img ( ax , name = 'NASA_simple_currents' ) # Add dataset and map sources source_text = \"\"\" Source credits: winds data from ERA5 reanalysis and background image from NASA images created by @senclimate \"\"\" ax . text ( 0.5 , - 0.2 , source_text , transform = ax . transAxes , fontsize = 10 , color = 'black' , alpha = 0.8 , ha = 'center' , va = 'bottom' , zorder = 6 ) fig . tight_layout () 1. Trade Winds \u00b6 North and South Equatorial Currents \u00b6 In the tropics, the prevailing winds are the easterly trade winds. These winds blow from east to west, driving the surface waters, which results in the formation of the North and South Equatorial Currents that flow in the same direction as the winds. Equatorial Counter Current \u00b6 Coriolis Effect : Due to the Earth's rotation, moving fluids (like air and water) are deflected by the Coriolis effect. Near the equator, the Coriolis effect is weakest, which means water can pile up in the western part of ocean basins more than in the eastern part. Difference in Sea Level : Because of the consistent push of the trade winds and the Coriolis effect, the sea level in the western tropical oceans is higher than in the eastern tropical oceans. This creates a gradient, or a slope in the sea surface, from west to east. Return Flow : To balance the accumulation of water in the western tropics and the sea surface height difference, there is a return flow of water at the surface from west to east. This return flow occurs in a narrow band along the equator and is known as the Equatorial Counter Current . Upwelling : In some areas, especially off the coast of continents (like off the west coast of Africa in the Atlantic), cold water from the depths is brought to the surface due to the divergence of surface waters. This upwelling, especially in the eastern part of ocean basins, reinforces the east-west sea surface height gradient. 2. Westerlies \u00b6 In the mid-latitudes (between 30\u00b0 and 60\u00b0), the prevailing winds are westerlies, blowing from west to east. These influence the formation of mid-latitude oceanic gyres. 3. Gyres \u00b6 Large, circular loops of water present in main ocean basins. Each ocean basin typically has a gyre in both the northern and southern hemispheres. Gyres comprise: - Equatorial currents - Western boundary currents (e.g., the Gulf Stream in the North Atlantic) - Eastern boundary currents (e.g., the California Current in the North Pacific) - High-latitude currents 4. Coriolis Effect \u00b6 Due to Earth's rotation, moving fluids deflect to the right in the Northern Hemisphere and to the left in the Southern Hemisphere. This effect is pivotal for the gyres and oceanic current direction. 5. Ekman Phenomena \u00b6 Ekman Spiral : A profile of water movement through depth with each successive layer moving at a slightly different angle due to the wind's influence and the Coriolis effect. Ekman Transport : The net transport of water resulting from the Ekman Spiral, typically at a 90\u00b0 angle to the wind direction. 6. Vertical Movements \u00b6 Upwelling : Where wind drives surface waters away, deeper, colder, nutrient-rich waters rise to the surface. Downwelling : In areas where wind pushes surface waters toward the coast or converges, water sinks. 7. Boundary Currents \u00b6 Western Boundary Currents : Narrow, fast, and deep currents (e.g., Gulf Stream, Kuroshio Current). Eastern Boundary Currents : Broader, slower, and shallower currents (e.g., California Current, Canary Current). Combined with thermohaline circulation, wind-driven circulation forms the global ocean conveyor belt , essential for redistributing heat, regulating climate","title":"Surface wind and currents"},{"location":"Clim_winds_map/#-wind-driven-ocean-criculation-","text":"","title":"\ud83c\udf0d Wind-driven ocean criculation \ud83c\udf0a"},{"location":"Clim_winds_map/#codes","text":"Load basic library for calculating and visualization % config IPCompleter . greedy = True % matplotlib inline % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 import warnings warnings . filterwarnings ( 'ignore' ) import numpy as np import xarray as xr import senpy as sp Load ERA5 reanalysis surface winds wind_ds = sp . ERA5_onelevel_vars ( vars = [ 'u10' , 'v10' ], time_slice = slice ( '1979-01' , '2022-12' )) wind_m = wind_ds . clim . climatology ( clim_slice = slice ( '1979-01' , '2022-12' )) . mean ( 'month' ) . load () plot annual mean surface wind climatology and overlayed image of ocean currents pattern credited from NASA images (ftp://public.sos.noaa.gov/oceans/) dlon = 10 dlat = 5 u = wind_m [ 'u10' ][:: dlat , :: dlon ] v = wind_m [ 'v10' ][:: dlat , :: dlon ] fig , ax = sp . map_subplots ( 1 , 1 , figsize = ( 10 , 5 ), proj = 'robin' , lon_0 = 200 , aspect = 1.2 , layout = 'compressed' ) quiver_scale = 40 # 40 m/s corresponds to 1 inch on the plot quiver_key_length = 10 # The reference arrow in the legend represents 10 m/s Q = ax . quiver ( u . lon , u . lat , u . values , v . values , scale = quiver_scale , scale_units = 'inches' , transform = sp . data_crs , pivot = 'middle' , color = 'blue' , zorder = 5 , alpha = 0.7 ) # Add a key to the plot to show vector scale qk = ax . quiverkey ( Q , 0.95 , 0.93 , quiver_key_length , f \" { quiver_key_length } m/s\" , labelpos = 'N' , coordinates = 'axes' ) # sp.map_coastline(ax, color='green') sp . map_landmask ( ax , fc = 'white' , alpha = 0.1 ) sp . map_ticks ( ax , lon_ticks = np . arange ( 20 , 360 , step = 60 ) ) ax . set_title ( \"Climatological surface winds and ocean currents\" , fontsize = 14 , fontweight = 'bold' ) sp . map_background_img ( ax , name = 'NASA_simple_currents' ) # Add dataset and map sources source_text = \"\"\" Source credits: winds data from ERA5 reanalysis and background image from NASA images created by @senclimate \"\"\" ax . text ( 0.5 , - 0.2 , source_text , transform = ax . transAxes , fontsize = 10 , color = 'black' , alpha = 0.8 , ha = 'center' , va = 'bottom' , zorder = 6 ) fig . tight_layout ()","title":"Codes"},{"location":"Clim_winds_map/#1-trade-winds","text":"","title":"1. Trade Winds"},{"location":"Clim_winds_map/#north-and-south-equatorial-currents","text":"In the tropics, the prevailing winds are the easterly trade winds. These winds blow from east to west, driving the surface waters, which results in the formation of the North and South Equatorial Currents that flow in the same direction as the winds.","title":"North and South Equatorial Currents"},{"location":"Clim_winds_map/#equatorial-counter-current","text":"Coriolis Effect : Due to the Earth's rotation, moving fluids (like air and water) are deflected by the Coriolis effect. Near the equator, the Coriolis effect is weakest, which means water can pile up in the western part of ocean basins more than in the eastern part. Difference in Sea Level : Because of the consistent push of the trade winds and the Coriolis effect, the sea level in the western tropical oceans is higher than in the eastern tropical oceans. This creates a gradient, or a slope in the sea surface, from west to east. Return Flow : To balance the accumulation of water in the western tropics and the sea surface height difference, there is a return flow of water at the surface from west to east. This return flow occurs in a narrow band along the equator and is known as the Equatorial Counter Current . Upwelling : In some areas, especially off the coast of continents (like off the west coast of Africa in the Atlantic), cold water from the depths is brought to the surface due to the divergence of surface waters. This upwelling, especially in the eastern part of ocean basins, reinforces the east-west sea surface height gradient.","title":"Equatorial Counter Current"},{"location":"Clim_winds_map/#2-westerlies","text":"In the mid-latitudes (between 30\u00b0 and 60\u00b0), the prevailing winds are westerlies, blowing from west to east. These influence the formation of mid-latitude oceanic gyres.","title":"2. Westerlies"},{"location":"Clim_winds_map/#3-gyres","text":"Large, circular loops of water present in main ocean basins. Each ocean basin typically has a gyre in both the northern and southern hemispheres. Gyres comprise: - Equatorial currents - Western boundary currents (e.g., the Gulf Stream in the North Atlantic) - Eastern boundary currents (e.g., the California Current in the North Pacific) - High-latitude currents","title":"3. Gyres"},{"location":"Clim_winds_map/#4-coriolis-effect","text":"Due to Earth's rotation, moving fluids deflect to the right in the Northern Hemisphere and to the left in the Southern Hemisphere. This effect is pivotal for the gyres and oceanic current direction.","title":"4. Coriolis Effect"},{"location":"Clim_winds_map/#5-ekman-phenomena","text":"Ekman Spiral : A profile of water movement through depth with each successive layer moving at a slightly different angle due to the wind's influence and the Coriolis effect. Ekman Transport : The net transport of water resulting from the Ekman Spiral, typically at a 90\u00b0 angle to the wind direction.","title":"5. Ekman Phenomena"},{"location":"Clim_winds_map/#6-vertical-movements","text":"Upwelling : Where wind drives surface waters away, deeper, colder, nutrient-rich waters rise to the surface. Downwelling : In areas where wind pushes surface waters toward the coast or converges, water sinks.","title":"6. Vertical Movements"},{"location":"Clim_winds_map/#7-boundary-currents","text":"Western Boundary Currents : Narrow, fast, and deep currents (e.g., Gulf Stream, Kuroshio Current). Eastern Boundary Currents : Broader, slower, and shallower currents (e.g., California Current, Canary Current). Combined with thermohaline circulation, wind-driven circulation forms the global ocean conveyor belt , essential for redistributing heat, regulating climate","title":"7. Boundary Currents"},{"location":"api/","text":"Top-level package for climatestate. app \u00b6 Main module.","title":"Api"},{"location":"api/#climatestate.app","text":"Main module.","title":"app"},{"location":"authors/","text":"Sen Zhao is assistant researcher in University of Hawaii at Manoa.","title":"Authors"},{"location":"climatology/","text":"winds \u00b6 \ud83c\udf0d Wind-driven ocean criculation \ud83c\udf0a \u00b6 Codes \u00b6 Load basic library for calculating and visualization % config IPCompleter . greedy = True % matplotlib inline % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 import warnings warnings . filterwarnings ( 'ignore' ) import numpy as np import xarray as xr import senpy as sp Load ERA5 reanalysis surface winds wind_ds = sp . ERA5_onelevel_vars ( vars = [ 'u10' , 'v10' ], time_slice = slice ( '1979-01' , '2022-12' )) wind_m = wind_ds . clim . climatology ( clim_slice = slice ( '1979-01' , '2022-12' )) . mean ( 'month' ) . load () plot annual mean surface wind climatology and overlayed image of ocean currents pattern credited from NASA images (ftp://public.sos.noaa.gov/oceans/) dlon = 10 dlat = 5 u = wind_m [ 'u10' ][:: dlat , :: dlon ] v = wind_m [ 'v10' ][:: dlat , :: dlon ] fig , ax = sp . map_subplots ( 1 , 1 , figsize = ( 10 , 5 ), proj = 'robin' , lon_0 = 200 , aspect = 1.2 , layout = 'compressed' ) quiver_scale = 40 # 40 m/s corresponds to 1 inch on the plot quiver_key_length = 10 # The reference arrow in the legend represents 10 m/s Q = ax . quiver ( u . lon , u . lat , u . values , v . values , scale = quiver_scale , scale_units = 'inches' , transform = sp . data_crs , pivot = 'middle' , color = 'blue' , zorder = 5 , alpha = 0.7 ) # Add a key to the plot to show vector scale qk = ax . quiverkey ( Q , 0.95 , 0.93 , quiver_key_length , f \" { quiver_key_length } m/s\" , labelpos = 'N' , coordinates = 'axes' ) # sp.map_coastline(ax, color='green') sp . map_landmask ( ax , fc = 'white' , alpha = 0.1 ) sp . map_ticks ( ax , lon_ticks = np . arange ( 20 , 360 , step = 60 ) ) ax . set_title ( \"Climatological surface winds and ocean currents\" , fontsize = 14 , fontweight = 'bold' ) sp . map_background_img ( ax , name = 'NASA_simple_currents' ) # Add dataset and map sources source_text = \"\"\" Source credits: winds data from ERA5 reanalysis and background image from NASA images created by @senclimate \"\"\" ax . text ( 0.5 , - 0.2 , source_text , transform = ax . transAxes , fontsize = 10 , color = 'black' , alpha = 0.8 , ha = 'center' , va = 'bottom' , zorder = 6 ) fig . tight_layout () 1. Trade Winds \u00b6 North and South Equatorial Currents \u00b6 In the tropics, the prevailing winds are the easterly trade winds. These winds blow from east to west, driving the surface waters, which results in the formation of the North and South Equatorial Currents that flow in the same direction as the winds. Equatorial Counter Current \u00b6 Coriolis Effect : Due to the Earth's rotation, moving fluids (like air and water) are deflected by the Coriolis effect. Near the equator, the Coriolis effect is weakest, which means water can pile up in the western part of ocean basins more than in the eastern part. Difference in Sea Level : Because of the consistent push of the trade winds and the Coriolis effect, the sea level in the western tropical oceans is higher than in the eastern tropical oceans. This creates a gradient, or a slope in the sea surface, from west to east. Return Flow : To balance the accumulation of water in the western tropics and the sea surface height difference, there is a return flow of water at the surface from west to east. This return flow occurs in a narrow band along the equator and is known as the Equatorial Counter Current . Upwelling : In some areas, especially off the coast of continents (like off the west coast of Africa in the Atlantic), cold water from the depths is brought to the surface due to the divergence of surface waters. This upwelling, especially in the eastern part of ocean basins, reinforces the east-west sea surface height gradient. 2. Westerlies \u00b6 In the mid-latitudes (between 30\u00b0 and 60\u00b0), the prevailing winds are westerlies, blowing from west to east. These influence the formation of mid-latitude oceanic gyres. 3. Gyres \u00b6 Large, circular loops of water present in main ocean basins. Each ocean basin typically has a gyre in both the northern and southern hemispheres. Gyres comprise: - Equatorial currents - Western boundary currents (e.g., the Gulf Stream in the North Atlantic) - Eastern boundary currents (e.g., the California Current in the North Pacific) - High-latitude currents 4. Coriolis Effect \u00b6 Due to Earth's rotation, moving fluids deflect to the right in the Northern Hemisphere and to the left in the Southern Hemisphere. This effect is pivotal for the gyres and oceanic current direction. 5. Ekman Phenomena \u00b6 Ekman Spiral : A profile of water movement through depth with each successive layer moving at a slightly different angle due to the wind's influence and the Coriolis effect. Ekman Transport : The net transport of water resulting from the Ekman Spiral, typically at a 90\u00b0 angle to the wind direction. 6. Vertical Movements \u00b6 Upwelling : Where wind drives surface waters away, deeper, colder, nutrient-rich waters rise to the surface. Downwelling : In areas where wind pushes surface waters toward the coast or converges, water sinks. 7. Boundary Currents \u00b6 Western Boundary Currents : Narrow, fast, and deep currents (e.g., Gulf Stream, Kuroshio Current). Eastern Boundary Currents : Broader, slower, and shallower currents (e.g., California Current, Canary Current). Combined with thermohaline circulation, wind-driven circulation forms the global ocean conveyor belt , essential for redistributing heat, regulating climate SST \u00b6 SST map \u00b6 % config IPCompleter . greedy = True % matplotlib inline % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 # ignore warnings import warnings warnings . filterwarnings ( 'ignore' ) import numpy as np import xarray as xr import matplotlib import matplotlib.colors as colors import senpy as sp from senpy import cmap ## time_slice = slice ( '1979-01' , '2022-12' ) prec_ds = xr . open_dataset ( '/export/epekema/zhaos/data/sst/ERSSTv5/sst.mon.mean_1x1.nc' ) . sel ( time = time_slice )[ 'sst' ] prec_ds = prec_ds . reindex ( lat = sorted ( prec_ds . lat )) prec_ds = sp . add_cyclic_point ( prec_ds , dim = 'lon' ) prec_m = prec_ds . groupby ( 'time.month' ) . mean () prec_a = prec_ds . groupby ( 'time.month' ) - prec_m prec_stddev = prec_a . std ( 'time' ) group_var = { 'All-Months' : prec_m . mean ( 'month' ), 'DJF' : prec_m . sel ( month = [ 12 , 1 , 12 ]) . mean ( 'month' ), 'MAM' : prec_m . sel ( month = [ 3 , 4 , 5 ]) . mean ( 'month' ), 'JJA' : prec_m . sel ( month = [ 6 , 7 , 8 ]) . mean ( 'month' ), 'SON' : prec_m . sel ( month = [ 9 , 10 , 11 ]) . mean ( 'month' ), } # fig = cmap.listview_cmaps() prC_clevs , prC_cmap , prC_norm = cmap . level_cmap_norms ( name = 'BlGrYeOrReVi200' , reverse = False , levels = np . arange ( 0 , 30 , step = 1 ), extend = 'both' ,) prC_cmap # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, ax = sp.map_subplots( 1, 1, figsize=(6, 3), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , ax = sp . map_subplots ( 1 , 1 , figsize = ( 6 , 4 ), proj = 'cyl' , lon_0 = 205 , aspect = 1.25 , layout = 'compressed' ) sea = 'All-Months' var_ds = group_var [ sea ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs [:: 4 ]) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) ax . set_title ( 'Precipiation annual mean climatology: 1979-2022' , fontsize = 'x-large' , fontweight = 'bold' ) sp . savefig ( fig , 'Clim_sst_ann.pdf' ) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 4, 1, figsize=(6, 11), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , axes = sp . map_subplots ( 4 , 1 , figsize = ( 6 , 12 ), proj = 'cyl' , lon_0 = 180 , aspect = 1.25 , layout = 'compressed' ) for i , sea in enumerate ([ 'DJF' , 'MAM' , 'JJA' , 'SON' ]): ax = axes . flat [ i ] var_ds = group_var [ sea ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) ax . set_title ( sea , fontsize = 'x-large' , fontweight = 'bold' ) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs [:: 4 ]) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) sp . set_legend_alphabet ( fig , axes . flat , x = 0.05 , y = 0.98 ) sp . savefig ( fig , 'Clim_sst_seasons.pdf' ) from scipy.ndimage import gaussian_filter def smooth_gaussian ( scalar_grid , n ): # Compute standard deviation in a manner consistent with GEMPAK n = int ( round ( n )) n = max ( n , 2 ) sgma = n / ( 2 * np . pi ) # Construct sigma sequence so smoothing occurs only in horizontal direction num_ax = len ( scalar_grid . shape ) # Assume the last two axes represent the horizontal directions sgma_seq = [ sgma if i > num_ax - 3 else 0 for i in range ( num_ax )] filter_args = { 'sigma' : sgma_seq , 'truncate' : 2 * np . sqrt ( 2 )} if hasattr ( scalar_grid , 'mask' ): smoothed = gaussian_filter ( scalar_grid . data , ** filter_args ) return np . ma . array ( smoothed , mask = scalar_grid . mask ) else : return gaussian_filter ( scalar_grid , ** filter_args ) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, ax = sp.map_subplots( 1, 1, figsize=(6, 3), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , axes = sp . map_subplots ( 2 , 1 , figsize = ( 6 , 8 ), proj = 'cyl' , lon_0 = 205 , aspect = 1.25 , layout = 'compressed' ) ds_lists = list ( [ group_var [ 'MAM' ], xr . apply_ufunc ( smooth_gaussian , group_var [ 'MAM' ], kwargs = { 'n' : 4 }) ]) for i , ax in enumerate ( axes . flat ): var_ds = ds_lists [ i ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs ) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) # ax.set_title('Precipiation annual mean climatology: 1979-2022', fontsize='x-large', fontweight='bold')","title":"Climatology"},{"location":"climatology/#winds","text":"","title":"winds"},{"location":"climatology/#-wind-driven-ocean-criculation-","text":"","title":"\ud83c\udf0d Wind-driven ocean criculation \ud83c\udf0a"},{"location":"climatology/#codes","text":"Load basic library for calculating and visualization % config IPCompleter . greedy = True % matplotlib inline % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 import warnings warnings . filterwarnings ( 'ignore' ) import numpy as np import xarray as xr import senpy as sp Load ERA5 reanalysis surface winds wind_ds = sp . ERA5_onelevel_vars ( vars = [ 'u10' , 'v10' ], time_slice = slice ( '1979-01' , '2022-12' )) wind_m = wind_ds . clim . climatology ( clim_slice = slice ( '1979-01' , '2022-12' )) . mean ( 'month' ) . load () plot annual mean surface wind climatology and overlayed image of ocean currents pattern credited from NASA images (ftp://public.sos.noaa.gov/oceans/) dlon = 10 dlat = 5 u = wind_m [ 'u10' ][:: dlat , :: dlon ] v = wind_m [ 'v10' ][:: dlat , :: dlon ] fig , ax = sp . map_subplots ( 1 , 1 , figsize = ( 10 , 5 ), proj = 'robin' , lon_0 = 200 , aspect = 1.2 , layout = 'compressed' ) quiver_scale = 40 # 40 m/s corresponds to 1 inch on the plot quiver_key_length = 10 # The reference arrow in the legend represents 10 m/s Q = ax . quiver ( u . lon , u . lat , u . values , v . values , scale = quiver_scale , scale_units = 'inches' , transform = sp . data_crs , pivot = 'middle' , color = 'blue' , zorder = 5 , alpha = 0.7 ) # Add a key to the plot to show vector scale qk = ax . quiverkey ( Q , 0.95 , 0.93 , quiver_key_length , f \" { quiver_key_length } m/s\" , labelpos = 'N' , coordinates = 'axes' ) # sp.map_coastline(ax, color='green') sp . map_landmask ( ax , fc = 'white' , alpha = 0.1 ) sp . map_ticks ( ax , lon_ticks = np . arange ( 20 , 360 , step = 60 ) ) ax . set_title ( \"Climatological surface winds and ocean currents\" , fontsize = 14 , fontweight = 'bold' ) sp . map_background_img ( ax , name = 'NASA_simple_currents' ) # Add dataset and map sources source_text = \"\"\" Source credits: winds data from ERA5 reanalysis and background image from NASA images created by @senclimate \"\"\" ax . text ( 0.5 , - 0.2 , source_text , transform = ax . transAxes , fontsize = 10 , color = 'black' , alpha = 0.8 , ha = 'center' , va = 'bottom' , zorder = 6 ) fig . tight_layout ()","title":"Codes"},{"location":"climatology/#1-trade-winds","text":"","title":"1. Trade Winds"},{"location":"climatology/#north-and-south-equatorial-currents","text":"In the tropics, the prevailing winds are the easterly trade winds. These winds blow from east to west, driving the surface waters, which results in the formation of the North and South Equatorial Currents that flow in the same direction as the winds.","title":"North and South Equatorial Currents"},{"location":"climatology/#equatorial-counter-current","text":"Coriolis Effect : Due to the Earth's rotation, moving fluids (like air and water) are deflected by the Coriolis effect. Near the equator, the Coriolis effect is weakest, which means water can pile up in the western part of ocean basins more than in the eastern part. Difference in Sea Level : Because of the consistent push of the trade winds and the Coriolis effect, the sea level in the western tropical oceans is higher than in the eastern tropical oceans. This creates a gradient, or a slope in the sea surface, from west to east. Return Flow : To balance the accumulation of water in the western tropics and the sea surface height difference, there is a return flow of water at the surface from west to east. This return flow occurs in a narrow band along the equator and is known as the Equatorial Counter Current . Upwelling : In some areas, especially off the coast of continents (like off the west coast of Africa in the Atlantic), cold water from the depths is brought to the surface due to the divergence of surface waters. This upwelling, especially in the eastern part of ocean basins, reinforces the east-west sea surface height gradient.","title":"Equatorial Counter Current"},{"location":"climatology/#2-westerlies","text":"In the mid-latitudes (between 30\u00b0 and 60\u00b0), the prevailing winds are westerlies, blowing from west to east. These influence the formation of mid-latitude oceanic gyres.","title":"2. Westerlies"},{"location":"climatology/#3-gyres","text":"Large, circular loops of water present in main ocean basins. Each ocean basin typically has a gyre in both the northern and southern hemispheres. Gyres comprise: - Equatorial currents - Western boundary currents (e.g., the Gulf Stream in the North Atlantic) - Eastern boundary currents (e.g., the California Current in the North Pacific) - High-latitude currents","title":"3. Gyres"},{"location":"climatology/#4-coriolis-effect","text":"Due to Earth's rotation, moving fluids deflect to the right in the Northern Hemisphere and to the left in the Southern Hemisphere. This effect is pivotal for the gyres and oceanic current direction.","title":"4. Coriolis Effect"},{"location":"climatology/#5-ekman-phenomena","text":"Ekman Spiral : A profile of water movement through depth with each successive layer moving at a slightly different angle due to the wind's influence and the Coriolis effect. Ekman Transport : The net transport of water resulting from the Ekman Spiral, typically at a 90\u00b0 angle to the wind direction.","title":"5. Ekman Phenomena"},{"location":"climatology/#6-vertical-movements","text":"Upwelling : Where wind drives surface waters away, deeper, colder, nutrient-rich waters rise to the surface. Downwelling : In areas where wind pushes surface waters toward the coast or converges, water sinks.","title":"6. Vertical Movements"},{"location":"climatology/#7-boundary-currents","text":"Western Boundary Currents : Narrow, fast, and deep currents (e.g., Gulf Stream, Kuroshio Current). Eastern Boundary Currents : Broader, slower, and shallower currents (e.g., California Current, Canary Current). Combined with thermohaline circulation, wind-driven circulation forms the global ocean conveyor belt , essential for redistributing heat, regulating climate","title":"7. Boundary Currents"},{"location":"climatology/#sst","text":"","title":"SST"},{"location":"climatology/#sst-map","text":"% config IPCompleter . greedy = True % matplotlib inline % config InlineBackend . figure_format = 'retina' % load_ext autoreload % autoreload 2 # ignore warnings import warnings warnings . filterwarnings ( 'ignore' ) import numpy as np import xarray as xr import matplotlib import matplotlib.colors as colors import senpy as sp from senpy import cmap ## time_slice = slice ( '1979-01' , '2022-12' ) prec_ds = xr . open_dataset ( '/export/epekema/zhaos/data/sst/ERSSTv5/sst.mon.mean_1x1.nc' ) . sel ( time = time_slice )[ 'sst' ] prec_ds = prec_ds . reindex ( lat = sorted ( prec_ds . lat )) prec_ds = sp . add_cyclic_point ( prec_ds , dim = 'lon' ) prec_m = prec_ds . groupby ( 'time.month' ) . mean () prec_a = prec_ds . groupby ( 'time.month' ) - prec_m prec_stddev = prec_a . std ( 'time' ) group_var = { 'All-Months' : prec_m . mean ( 'month' ), 'DJF' : prec_m . sel ( month = [ 12 , 1 , 12 ]) . mean ( 'month' ), 'MAM' : prec_m . sel ( month = [ 3 , 4 , 5 ]) . mean ( 'month' ), 'JJA' : prec_m . sel ( month = [ 6 , 7 , 8 ]) . mean ( 'month' ), 'SON' : prec_m . sel ( month = [ 9 , 10 , 11 ]) . mean ( 'month' ), } # fig = cmap.listview_cmaps() prC_clevs , prC_cmap , prC_norm = cmap . level_cmap_norms ( name = 'BlGrYeOrReVi200' , reverse = False , levels = np . arange ( 0 , 30 , step = 1 ), extend = 'both' ,) prC_cmap # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, ax = sp.map_subplots( 1, 1, figsize=(6, 3), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , ax = sp . map_subplots ( 1 , 1 , figsize = ( 6 , 4 ), proj = 'cyl' , lon_0 = 205 , aspect = 1.25 , layout = 'compressed' ) sea = 'All-Months' var_ds = group_var [ sea ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs [:: 4 ]) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) ax . set_title ( 'Precipiation annual mean climatology: 1979-2022' , fontsize = 'x-large' , fontweight = 'bold' ) sp . savefig ( fig , 'Clim_sst_ann.pdf' ) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 4, 1, figsize=(6, 11), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , axes = sp . map_subplots ( 4 , 1 , figsize = ( 6 , 12 ), proj = 'cyl' , lon_0 = 180 , aspect = 1.25 , layout = 'compressed' ) for i , sea in enumerate ([ 'DJF' , 'MAM' , 'JJA' , 'SON' ]): ax = axes . flat [ i ] var_ds = group_var [ sea ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) ax . set_title ( sea , fontsize = 'x-large' , fontweight = 'bold' ) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs [:: 4 ]) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) sp . set_legend_alphabet ( fig , axes . flat , x = 0.05 , y = 0.98 ) sp . savefig ( fig , 'Clim_sst_seasons.pdf' ) from scipy.ndimage import gaussian_filter def smooth_gaussian ( scalar_grid , n ): # Compute standard deviation in a manner consistent with GEMPAK n = int ( round ( n )) n = max ( n , 2 ) sgma = n / ( 2 * np . pi ) # Construct sigma sequence so smoothing occurs only in horizontal direction num_ax = len ( scalar_grid . shape ) # Assume the last two axes represent the horizontal directions sgma_seq = [ sgma if i > num_ax - 3 else 0 for i in range ( num_ax )] filter_args = { 'sigma' : sgma_seq , 'truncate' : 2 * np . sqrt ( 2 )} if hasattr ( scalar_grid , 'mask' ): smoothed = gaussian_filter ( scalar_grid . data , ** filter_args ) return np . ma . array ( smoothed , mask = scalar_grid . mask ) else : return gaussian_filter ( scalar_grid , ** filter_args ) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 5), proj='robin', lon_0=205, aspect=1.) # fig, axes = sp.map_subplots( 2, 2, figsize=(12, 12), proj='lambertcyl', lon_0=205, aspect=1.) # fig, ax = sp.map_subplots( 1, 1, figsize=(6, 3), proj='lambertcyl', lon_0=180, aspect=1.5, layout='compressed') fig , axes = sp . map_subplots ( 2 , 1 , figsize = ( 6 , 8 ), proj = 'cyl' , lon_0 = 205 , aspect = 1.25 , layout = 'compressed' ) ds_lists = list ( [ group_var [ 'MAM' ], xr . apply_ufunc ( smooth_gaussian , group_var [ 'MAM' ], kwargs = { 'n' : 4 }) ]) for i , ax in enumerate ( axes . flat ): var_ds = ds_lists [ i ] imag0 = ax . contourf ( var_ds . lon , var_ds . lat , var_ds , levels = prC_clevs , cmap = prC_cmap , norm = prC_norm , extend = 'both' , transform = sp . data_crs ) # ax.pcolormesh(var_ds.lon, var_ds.lat, var_ds, cmap=prC_cmap, norm=prC_norm, transform=sp.data_crs) sp . map_coastline ( ax , scale = '110m' , color = 'black' ) sp . map_equator ( ax ,) sp . map_ticks ( ax , lat_lim = [ - 61 , 61 ]) cb = fig . colorbar ( imag0 , ax = [ ax ], location = 'right' , shrink = 0.9 , pad = 0.02 ) cb . set_ticks ( prC_clevs ) cb . ax . set_yticklabels ([ \" {:g} \" . format ( i ) for i in cb . get_ticks ()]) # cb = fig.colorbar(imag0, ax=[ax], location='bottom', shrink=0.8, pad=0.02) # cb.set_ticks(prC_clevs) # cb.ax.set_xticklabels([\"{:g}\".format(i) for i in cb.get_ticks()]) # ax.set_title('Precipiation annual mean climatology: 1979-2022', fontsize='x-large', fontweight='bold')","title":"SST map"},{"location":"history/","text":"History \u00b6 0.1.0 (2023-11-04) \u00b6 First release on PyPI.","title":"History"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-2023-11-04","text":"First release on PyPI.","title":"0.1.0 (2023-11-04)"}]}